/*
 * 版权所有（c）<2021><蔡永程>
 *
 * 反996许可证版本1.0
 *
 * 在符合下列条件的情况下，特此免费向任何得到本授权作品的副本（包括源代码、文件和/或相关内容，以
 * 下统称为“授权作品”）的个人和法人实体授权：被授权个人或法人实体有权以任何目的处置授权作品，包括
 * 但不限于使用、复制，修改，衍生利用、散布，发布和再许可：
 *
 * 1. 个人或法人实体必须在许可作品的每个再散布或衍生副本上包含以上版权声明和本许可证，不得自行修
 * 改。
 * 2. 个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或经营地（
 * 以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和标准。如果该司法管辖区
 * 没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可执行，则个人或法人实体必须遵守国际
 * 劳工标准的核心公约。
 * 3. 个人或法人不得以任何方式诱导、暗示或强迫其全职或兼职员工或其独立承包人以口头或书面形式同意
 * 直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和标准保护的权利
 * 或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该等个人或法人实体也不得以任
 * 何方法限制其雇员或独立承包人向版权持有人或监督许可证合规情况的有关当局报告或投诉上述违反许可证
 * 的行为的权利。
 *
 * 该授权作品是"按原样"提供，不做任何明示或暗示的保证，包括但不限于对适销性、特定用途适用性和非侵
 * 权性的保证。在任何情况下，无论是在合同诉讼、侵权诉讼或其他诉讼中，版权持有人均不承担因本软件或
 * 本软件的使用或其他交易而产生、引起或与之相关的任何索赔、损害或其他责任。
 */

package letcode.normal.unansweredquestions.difficult;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Caiyongcheng
 * @description 给你两个下标从 0 开始的数组 nums1 和 nums2 ，和一个二维数组 queries 表示一些操作。
 * 总共有 3 种类型的操作：
 * 操作类型 1 为 queries[i] = [1, l, r] 。你需要将 nums1 从下标 l 到下标 r 的所有 0 反转成 1 或将 1 反转成 0 。l 和 r 下标都从 0 开始。
 * 操作类型 2 为 queries[i] = [2, p, 0] 。对于 0 <= i < n 中的所有下标，令 nums2[i] = nums2[i] + nums1[i] * p 。
 * 操作类型 3 为 queries[i] = [3, 0, 0] 。求 nums2 中所有元素的和。 请你返回一个数组，包含所有第三种操作类型的答案。
 * @since 2023/7/26 14:47
 */
public class N_2569 {


    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {
        /*
        操作1 只会让nums1的值从0变1 或者从1变0 所以nums1的值 只能是0或者1。反转奇次会取反，偶数则不变
        操作2 nums2[i] = nums2[i] + nums1[i] * p 如果nums1[i]=0,那么就不需要计算，所以只关注取1的部分
        操作3 对于nums2的数组和而言，nums2只会增加，增加量等于每次操作2的增量之和 也就是nums[1]中1的数量*p

        总上所述 只关心操作2的增量 =》 nums1中为1的数量 => 如果直接操作nums1 则每次进行r-l次的操作 可能会超时
        所以要优化计算方式 (l1,r1) 和(l2,r2)的关系，要么是交叉，要么是无关系。对于交叉部分，因为重叠了两次，所以不会取反。那么除去重叠部分
        即为取反部分。最后将得出的取反部分用于计算nums1（遇到操作2才会进行计算），还可以利用前缀和减少计算量。最多只有nums1.length操作量
         */

        //存储返回结果
        List<Long> res = new ArrayList<>(queries.length);

        //计算前缀和
        int[] preSumArr = new int[nums1.length];
        preSumArr[0] = nums1[0];
        for (int i = 1; i < nums1.length; i++) {
            preSumArr[i] = preSumArr[i - 1] + nums1[i];
        }
        //构建计算变更的区间集合 有序 便于二分检索
        List<int[]> rangeList = new ArrayList<>(queries.length);
        return new long[]{};

    }

}
