/*
 * 版权所有（c）<2021><蔡永程>
 *
 * 反996许可证版本1.0
 *
 * 在符合下列条件的情况下，特此免费向任何得到本授权作品的副本（包括源代码、文件和/或相关内容，以
 * 下统称为“授权作品”）的个人和法人实体授权：被授权个人或法人实体有权以任何目的处置授权作品，包括
 * 但不限于使用、复制，修改，衍生利用、散布，发布和再许可：
 *
 * 1. 个人或法人实体必须在许可作品的每个再散布或衍生副本上包含以上版权声明和本许可证，不得自行修
 * 改。
 * 2. 个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或经营地（
 * 以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和标准。如果该司法管辖区
 * 没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可执行，则个人或法人实体必须遵守国际
 * 劳工标准的核心公约。
 * 3. 个人或法人不得以任何方式诱导、暗示或强迫其全职或兼职员工或其独立承包人以口头或书面形式同意
 * 直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和标准保护的权利
 * 或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该等个人或法人实体也不得以任
 * 何方法限制其雇员或独立承包人向版权持有人或监督许可证合规情况的有关当局报告或投诉上述违反许可证
 * 的行为的权利。
 *
 * 该授权作品是"按原样"提供，不做任何明示或暗示的保证，包括但不限于对适销性、特定用途适用性和非侵
 * 权性的保证。在任何情况下，无论是在合同诉讼、侵权诉讼或其他诉讼中，版权持有人均不承担因本软件或
 * 本软件的使用或其他交易而产生、引起或与之相关的任何索赔、损害或其他责任。
 */

package letcode.normal.difficult;

import java.util.Arrays;

/**
 * Leetcode
 * 编写一个程序，通过已填充的空格来解决数独问题。  一个数独的解法需遵循如下规则：  数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。  来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sudoku-solver 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 * @author : CaiYongcheng
 * @date : 2020-07-31 09:06
 **/
public class _37ThirtyserSeven {

    private boolean[][] mass = new boolean[9][9];
    private boolean[][] rows = new boolean[9][9];
    private boolean[][] cols = new boolean[9][9];
    private char[][] datas;

    public static void main(String[] args) {
        char[][] board = {
                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
        };
        new _37ThirtyserSeven().solveSudoku(board);
        for (char[] chars : board) {
            System.out.println(Arrays.toString(chars));
        }
    }

    private void init() {
        int data = 0;
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (datas[row][col] != '.') {
                    data = datas[row][col] - '0' - 1;
                    rows[row][data] = true;
                    cols[col][data] = true;
                    mass[row / 3 * 3 + col / 3][data] = true;
                }
            }
        }
    }

    private boolean dfs(int row, int col) {
        // 找到下一个填充位置
        for (; row < 9; ++row) {
            for (col = 0; col < 9; ++col) {
                if (datas[row][col] == '.') {
                    break;
                }
            }
            if (col < 9) {
                break;
            }
        }
        // 填充完成表明填充成功
        if (row >= 9) {
            return true;
        }
        int massIndex = row / 3 * 3 + col / 3;
        for (int index = 0; index < 9; ++index) {
            // 这个数字可以使用
            if ((!rows[row][index]) && (!cols[col][index])
                    && (!mass[massIndex][index])) {
                rows[row][index] = true;
                cols[col][index] = true;
                mass[massIndex][index] = true;
                datas[row][col] = (char) (index + '1');
                if (dfs(row, col)) {
                    return true;
                }
                rows[row][index] = false;
                cols[col][index] = false;
                mass[massIndex][index] = false;
                datas[row][col] = '.';
            }
        }
        return false;
    }

    /**
     * {
     * {'5','3','.','.','7','.','.','.','.'},
     * {'6','.','.','1','9','5','.','.','.'},
     * {'.','9','8','.','.','.','.','6','.'},
     * {'8','.','.','.','6','.','.','.','3'},
     * {'4','.','.','8','.','3','.','.','1'},
     * {'7','.','.','.','2','.','.','.','6'},
     * {'.','6','.','.','.','.','2','8','.'},
     * {'.','.','.','4','1','9','.','.','5'},
     * {'.','.','.','.','8','.','.','7','9'}
     * }
     * {
     * {'5','3','4','6','7','8','9','1','2'},
     * {'6','7','2','1','9','5','3','4','8'},
     * {'1','9','8','3','4','2','5','6','7'},
     * {'8','5','9','7','6','1','4','2','3'},
     * {'4','2','6','8','5','3','7','9','1'},
     * {'7','1','3','9','2','4','8','5','6'},
     * {'9','6','1','5','3','7','2','8','4'},
     * {'2','8','7','4','1','9','6','3','5'},
     * {'3','4','5','2','8','6','1','7','9'}
     * }
     */
    public void solveSudoku(char[][] board) {
        datas = board;
        init();
        dfs(0, 0);
    }
}
